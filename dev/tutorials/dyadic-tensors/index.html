<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dyadic tensor product ‚äó ¬∑ Grassmann.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Grassmann.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Grassmann.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../design/">Design</a></li><li><a class="tocitem" href="../../algebra/">Algebra</a></li><li><a class="tocitem" href="../../library/">Library</a></li><li><a class="tocitem" href="../../agpl/">AGPL-3.0</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../quick-start/">Quick start (G2)</a></li><li><a class="tocitem" href="../algebra-of-space/">The Algebra of Space (G3)</a></li><li class="is-active"><a class="tocitem" href>Dyadic tensor product ‚äó</a><ul class="internal"><li><a class="tocitem" href="#Nested-dyadic-algebra"><span>Nested dyadic algebra</span></a></li><li><a class="tocitem" href="#Mother-algebra-formalism"><span>Mother algebra formalism</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Dyadic tensor product ‚äó</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dyadic tensor product ‚äó</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chakravala/Grassmann.jl/blob/master/docs/src/tutorials/dyadic-tensors.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dyadic-tensor-product"><a class="docs-heading-anchor" href="#Dyadic-tensor-product">Dyadic tensor product ‚äó</a><a id="Dyadic-tensor-product-1"></a><a class="docs-heading-anchor-permalink" href="#Dyadic-tensor-product" title="Permalink"></a></h1><p>Dyadic tensors are represented with the Grassmann‚Äôs exterior product algebra or nested <code>Chain{V,1,Chain{V,1}}</code> elements, generating a <span>$2^{2n}$</span>-dimensional mother algebra with the direct sum of the <span>$n$</span>-dimensional vector space and its dual vector space. The product of the vector basis and covector basis elements form the <span>$n^2$</span>-dimensional bivector subspace of the full <span>$\frac{(2n)!}{2(2n‚àí2)!}$</span>-dimensional bivector sub-algebra. The package <code>Grassmann</code> is working towards making the full extent of this number system available in Julia by using static compiled parametric type information to handle sparse sub-algebras, such as the dyadic (1,1)-tensor bivector algebra or mother algebra.</p><h2 id="Nested-dyadic-algebra"><a class="docs-heading-anchor" href="#Nested-dyadic-algebra">Nested dyadic algebra</a><a id="Nested-dyadic-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-dyadic-algebra" title="Permalink"></a></h2><p>In this algebra, it&#39;s possible to compute on a mesh of arbitrary 5 dimensional conformal geometric algebra simplices, which can be represented by a bundle of  nested dyadic tensors.</p><pre><code class="language-julia-repl">julia&gt; using Grassmann, StaticArrays; basis&quot;+-+++&quot;
(‚ü®+-+++‚ü©, v, v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, v‚ÇÑ, v‚ÇÖ, v‚ÇÅ‚ÇÇ, v‚ÇÅ‚ÇÉ, v‚ÇÅ‚ÇÑ, v‚ÇÅ‚ÇÖ, v‚ÇÇ‚ÇÉ, v‚ÇÇ‚ÇÑ, v‚ÇÇ‚ÇÖ, v‚ÇÉ‚ÇÑ, v‚ÇÉ‚ÇÖ, v‚ÇÑ‚ÇÖ, v‚ÇÅ‚ÇÇ‚ÇÉ, v‚ÇÅ‚ÇÇ‚ÇÑ, v‚ÇÅ‚ÇÇ‚ÇÖ, v‚ÇÅ‚ÇÉ‚ÇÑ, v‚ÇÅ‚ÇÉ‚ÇÖ, v‚ÇÅ‚ÇÑ‚ÇÖ, v‚ÇÇ‚ÇÉ‚ÇÑ, v‚ÇÇ‚ÇÉ‚ÇÖ, v‚ÇÇ‚ÇÑ‚ÇÖ, v‚ÇÉ‚ÇÑ‚ÇÖ, v‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ, v‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÖ, v‚ÇÅ‚ÇÇ‚ÇÑ‚ÇÖ, v‚ÇÅ‚ÇÉ‚ÇÑ‚ÇÖ, v‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ, v‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ)

julia&gt; value(rand(Chain{V,1,Chain{V,1}}))
5-element Values{5, Chain{‚ü®+-+++‚ü©, 1, ùïÇ, var&quot;257&quot;} where {ùïÇ, var&quot;257&quot;}} with indices SOneTo(5):
    0.1881799698014297v‚ÇÅ - 0.4767689621958229v‚ÇÇ + 0.6385289385344683v‚ÇÉ - 0.8223496218274171v‚ÇÑ - 0.6705222309173395v‚ÇÖ
  0.6717522540304408v‚ÇÅ - 0.010956566350879715v‚ÇÇ - 0.9709361897361872v‚ÇÉ + 0.3196799519849334v‚ÇÑ - 0.8920460944921587v‚ÇÖ
   -0.2274956920123632v‚ÇÅ - 0.7230578061934674v‚ÇÇ - 0.1920204247428905v‚ÇÉ - 0.7563407430283222v‚ÇÑ - 0.7438358471165749v‚ÇÖ
 -0.3017901940799508v‚ÇÅ - 0.15101045706818095v‚ÇÇ - 0.27254340898133744v‚ÇÉ + 0.2062547749524568v‚ÇÑ + 0.8875228668312087v‚ÇÖ
   -0.9239312658401491v‚ÇÅ + 0.6564228026279886v‚ÇÇ + 0.617001282483939v‚ÇÉ + 0.35394722921206867v‚ÇÑ + 0.9204095438232258v‚ÇÖ

julia&gt; A = Chain{V,1}(rand(SMatrix{5,5}))
(0.5003718861417434v‚ÇÅ + 0.37839171484112977v‚ÇÇ + 0.5234641049661983v‚ÇÉ + 0.685191800914702v‚ÇÑ + 0.009611877189267037v‚ÇÖ)v‚ÇÅ + (0.8413882656829386v‚ÇÅ + 0.35225733728096476v‚ÇÇ + 0.8572501528816878v‚ÇÉ + 0.24842008201644683v‚ÇÑ + 0.23669193859086324v‚ÇÖ)v‚ÇÇ + (0.20662652364308798v‚ÇÅ + 0.850620183852046v‚ÇÇ + 0.1074259835812914v‚ÇÉ + 0.11626540474689206v‚ÇÑ + 0.8841043376709936v‚ÇÖ)v‚ÇÉ + (0.8387070338020381v‚ÇÅ + 0.23649120077761787v‚ÇÇ + 0.8624317037042386v‚ÇÉ + 0.6116506201471525v‚ÇÑ + 0.375690101652536v‚ÇÖ)v‚ÇÑ + (0.9568853090025073v‚ÇÅ + 0.04540602631261903v‚ÇÇ + 0.3728724070072633v‚ÇÉ + 0.9376263932209163v‚ÇÑ + 0.2839030188336873v‚ÇÖ)v‚ÇÖ</code></pre><p>Additionally, in Grassmann.jl we prefer the nested usage of pure <code>ChainBundle</code> parametric types for large re-usable global cell geometries, from which local dyadics can be selected.</p><p>Programming the <code>A\b</code> method is straight forward with some Julia language metaprogramming and Grassmann.jl by first instantiating some Cramer symbols</p><pre><code class="language-julia-repl">julia&gt; Base.@pure function Grassmann.Cramer(N::Int)
           x,y = SVector{N}([Symbol(:x,i) for i ‚àà 1:N]),SVector{N}([Symbol(:y,i) for i ‚àà 1:N])
           xy = [:(($(x[1+i]),$(y[1+i])) = ($(x[i])‚àßt[$(1+i)],t[end-$i]‚àß$(y[i]))) for i ‚àà 1:N-1]
           return x,y,xy
       end</code></pre><p>These are exterior product variants of the Cramer determinant symbols (<span>$N!$</span> times <span>$N$</span>-simplex hypervolumes), which can be combined to directly solve a linear system:</p><pre><code class="language-julia-repl">julia&gt; @generated function Base.:\(t::Chain{V,1,&lt;:Chain{V,1}},v::Chain{V,1}) where V
           N = ndims(V)-1 # paste this into the REPL for faster eval
           x,y,xy = Grassmann.Cramer(N)
           mid = [:($(x[i])‚àßv‚àß$(y[end-i])) for i ‚àà 1:N-1]
           out = Expr(:call,:SVector,:(v‚àß$(y[end])),mid...,:($(x[end])‚àßv))
           return Expr(:block,:((x1,y1)=(t[1],t[end])),xy...,
               :(Chain{V,1}(getindex.($(Expr(:call,:./,out,:(t[1]‚àß$(y[end])))),1))))
       end</code></pre><p>Which results in the following highly efficient <code>@generated</code> code for solving the linear system,</p><pre><code class="language-Julia">(x1, y1) = (t[1], t[end])
(x2, y2) = (x1 ‚àß t[2], t[end - 1] ‚àß y1)
(x3, y3) = (x2 ‚àß t[3], t[end - 2] ‚àß y2)
(x4, y4) = (x3 ‚àß t[4], t[end - 3] ‚àß y3)
Chain{V, 1}(getindex.(SVector(v ‚àß y4, (x1 ‚àß v) ‚àß y3, (x2 ‚àß v) ‚àß y2, (x3 ‚àß v) ‚àß y1, x4 ‚àß v) ./ (t[1] ‚àß y4), 1))</code></pre><p>Benchmarks with that algebra indicate a <span>$3\times$</span> faster performance than <code>SMatrix</code> for applying <code>A\b</code> to bundles of dyadic elements.</p><pre><code class="language-Julia">julia&gt; @btime $(rand(SMatrix{5,5},10000)).\Ref($(SVector(1,2,3,4,5)));
  2.588 ms (29496 allocations: 1.44 MiB)

julia&gt; @btime $(Chain{V,1}.(rand(SMatrix{5,5},10000))).\$(v1+2v2+3v3+4v4+5v5);
  808.631 Œºs (2 allocations: 390.70 KiB)

julia&gt; @btime $(SMatrix(A))\$(SVector(1,2,3,4,5))
  150.663 ns (0 allocations: 0 bytes)
5-element SArray{Tuple{5},Float64,1,5} with indices SOneTo(5):
 -4.783720495603508
  6.034887114999602
  1.017847212237964
  6.379374861538397
 -4.158116538111051

julia&gt; @btime $A\$(v1+2v2+3v3+4v4+5v5)
  72.405 ns (0 allocations: 0 bytes)
-4.783720495603519v‚ÇÅ + 6.034887114999605v‚ÇÇ + 1.017847212237964v‚ÇÉ + 6.379374861538393v‚ÇÑ - 4.1581165381110505v‚ÇÖ</code></pre><p>Such a solution is not only more efficient than Julia&#39;s <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> method for <code>SMatrix</code>, but is also useful to minimize allocations in Grassmann.jl finite element assembly.</p><p>Similarly, the Cramer symbols can also be manipulated to invert the linear system or for determining whether a point is within a simplex.</p><pre><code class="language-julia-repl">julia&gt; using Grassmann; @basis ‚Ñù3
(‚ü®√ó√ó√ó‚ü©, v, v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, v‚ÇÅ‚ÇÇ, v‚ÇÅ‚ÇÉ, v‚ÇÇ‚ÇÉ, v‚ÇÅ‚ÇÇ‚ÇÉ)

julia&gt; T = Chain{V,1}(Chain(v1),v1+v2,v1+v3)
(1v‚ÇÅ + 0v‚ÇÇ + 0v‚ÇÉ)v‚ÇÅ + (1v‚ÇÅ + 1v‚ÇÇ + 0v‚ÇÉ)v‚ÇÇ + (1v‚ÇÅ + 0v‚ÇÇ + 1v‚ÇÉ)v‚ÇÉ

julia&gt; barycenter(T) ‚àà T, (v1+v2+v3) ‚àà T
(true, false)</code></pre><p>Of course, there are multiple equivalent ways of computing the same results using the <code>‚ãÖ</code> and <code>:</code> dyadic products.</p><pre><code class="language-julia-repl">julia&gt; T\barycenter(T) == inv(T)‚ãÖbarycenter(T)
ERROR: DimensionMismatch(&quot;expected input array of length -1, got length 0&quot;)

julia&gt; sqrt(T:T) == norm(SMatrix(T))
true</code></pre><p>It is possible to generate a <a href="https://github.com/JuliaPlots/Makie.jl">Makie.jl</a> <code>streamplot</code> diagrams with the <code>Grassmann.Cramer</code> method for interpolated data of finite element solutions.</p><h2 id="Mother-algebra-formalism"><a class="docs-heading-anchor" href="#Mother-algebra-formalism">Mother algebra formalism</a><a id="Mother-algebra-formalism-1"></a><a class="docs-heading-anchor-permalink" href="#Mother-algebra-formalism" title="Permalink"></a></h2><p>Note that <code>Œõ(‚Ñù3)</code> gives the vector basis, and <code>Œõ(‚Ñù3)&#39;</code> gives the covector basis:</p><pre><code class="language-julia-repl">julia&gt; Œõ(‚Ñù3)
DirectSum.Basis{‚ü®√ó√ó√ó‚ü©,8}(v, v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, v‚ÇÅ‚ÇÇ, v‚ÇÅ‚ÇÉ, v‚ÇÇ‚ÇÉ, v‚ÇÅ‚ÇÇ‚ÇÉ)

julia&gt; Œõ(‚Ñù3)&#39;
DirectSum.Basis{‚ü®---‚ü©&#39;,8}(w, w¬π, w¬≤, w¬≥, w¬π¬≤, w¬π¬≥, w¬≤¬≥, w¬π¬≤¬≥)</code></pre><p>The following command yields a local 2D vector and covector basis,</p><pre><code class="language-julia-repl">julia&gt; @mixedbasis ‚Ñù2
(‚ü®++--‚ü©*, v, v‚ÇÅ, v‚ÇÇ, w¬π, w¬≤, v‚ÇÅ‚ÇÇ, v‚ÇÅw¬π, v‚ÇÅw¬≤, v‚ÇÇw¬π, v‚ÇÇw¬≤, w¬π¬≤, v‚ÇÅ‚ÇÇw¬π, v‚ÇÅ‚ÇÇw¬≤, v‚ÇÅw¬π¬≤, v‚ÇÇw¬π¬≤, v‚ÇÅ‚ÇÇw¬π¬≤)

julia&gt; w1+2w2
1w¬π + 2w¬≤

julia&gt; ans(v1+v2)
3v</code></pre><p>The sum <code>w1+2w2</code> is interpreted as a covector element of the dual vector space, which can be evaluated as a linear functional when a vector argument is input. Using these in the workspace, it is possible to use the Grassmann exterior <span>$\wedge$</span>-tensor product operation to construct elements <code>‚Ñí</code> of the dyadic (1,1)-bivector subspace of linear transformations from the mother algebra.</p><pre><code class="language-julia-repl">julia&gt; ‚Ñí = (v1+2v2)‚àß(3w1+4w2)
0v‚ÇÅ‚ÇÇ + 3v‚ÇÅw¬π + 4v‚ÇÅw¬≤ + 6v‚ÇÇw¬π + 8v‚ÇÇw¬≤ + 0w¬π¬≤</code></pre><p>The element <code>‚Ñí</code> is a linear form which can be evaluated,</p><pre><code class="language-julia-repl">julia&gt; ‚Ñí(v1+v2)
7v‚ÇÅ + 14v‚ÇÇ + 0w¬π + 0w¬≤

julia&gt; L = [1,2] * [3,4]&#39;; L * [1,1]
2-element Vector{Int64}:
  7
 14</code></pre><p>which is a computation equivalent to a matrix computation.</p><p>The <code>TensorAlgebra</code> evalution is still a work in progress, and the API and implementation may change as more features and algebraic operations and product structure are added.</p><h3 id="Importing-the-Leech-lattice-generator"><a class="docs-heading-anchor" href="#Importing-the-Leech-lattice-generator">Importing the Leech lattice generator</a><a id="Importing-the-Leech-lattice-generator-1"></a><a class="docs-heading-anchor-permalink" href="#Importing-the-Leech-lattice-generator" title="Permalink"></a></h3><p>In the example below, we define a constant <code>Leech</code> which can be used to obtain linear combinations of the Leech lattice,</p><pre><code class="language-julia">julia&gt; using Grassmann

julia&gt; generator = [8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       4 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       4 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       4 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       4 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       4 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       4 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       4 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
       4 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0;
       2 2 2 2 0 0 0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0;
       4 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0;
       2 2 0 0 2 2 0 0 2 2 0 0 2 2 0 0 0 0 0 0 0 0 0 0;
       2 0 2 0 2 0 2 0 2 0 2 0 2 0 2 0 0 0 0 0 0 0 0 0;
       2 0 0 2 2 0 0 2 2 0 0 2 2 0 0 2 0 0 0 0 0 0 0 0;
       4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0;
       2 0 2 0 2 0 0 2 2 2 0 0 0 0 0 0 2 2 0 0 0 0 0 0;
       2 0 0 2 2 2 0 0 2 0 2 0 0 0 0 0 2 0 2 0 0 0 0 0;
       2 2 0 0 2 0 2 0 2 0 0 2 0 0 0 0 2 0 0 2 0 0 0 0;
       0 2 2 2 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0;
       0 0 0 0 0 0 0 0 2 2 0 0 2 2 0 0 2 2 0 0 2 2 0 0;
       0 0 0 0 0 0 0 0 2 0 2 0 2 0 2 0 2 0 2 0 2 0 2 0;
       -3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]

julia&gt; const E24,W24 = Œõ(24), ‚Ñù^24‚äï(‚Ñù^24)&#39;;

julia&gt; const Leech = Chain{SubManifold(W24),Float64}(generator./sqrt(8));

julia&gt; typeof(Leech)
Chain{‚ü®++++++++++++++++++++++++------------------------‚ü©*,2,Float64,1128}

julia&gt; ndims(Manifold(Leech))
48</code></pre><p>The <code>Leech</code> generator matrix is contained in the 1128-dimensional bivector subalgebra of the space with 48 indices.</p><pre><code class="language-julia">julia&gt; Leech(E24.v1)
2.82842712474619v‚ÇÅ + 0.0v‚ÇÇ + 0.0v‚ÇÉ + 0.0v‚ÇÑ + 0.0v‚ÇÖ + 0.0v‚ÇÜ + 0.0v‚Çá + 0.0v‚Çà + 0.0v‚Çâ + 0.0v‚ÇÄ + 0.0va + 0.0vb + 0.0vc + 0.0vd + 0.0ve + 0.0vf + 0.0vg + 0.0vh + 0.0vi + 0.0vj + 0.0vk + 0.0vl + 0.0vm + 0.0vn + 0.0w¬π + 0.0w¬≤ + 0.0w¬≥ + 0.0w‚Å¥ + 0.0w‚Åµ + 0.0w‚Å∂ + 0.0w‚Å∑ + 0.0w‚Å∏ + 0.0w‚Åπ + 0.0w‚Å∞ + 0.0wA + 0.0wB + 0.0wC + 0.0wD + 0.0wE + 0.0wF + 0.0wG + 0.0wH + 0.0wI + 0.0wJ + 0.0wK + 0.0wL + 0.0wM + 0.0wN

julia&gt; Leech(E24.v2)
1.414213562373095v‚ÇÅ + 1.414213562373095v‚ÇÇ + 0.0v‚ÇÉ + 0.0v‚ÇÑ + 0.0v‚ÇÖ + 0.0v‚ÇÜ + 0.0v‚Çá + 0.0v‚Çà + 0.0v‚Çâ + 0.0v‚ÇÄ + 0.0va + 0.0vb + 0.0vc + 0.0vd + 0.0ve + 0.0vf + 0.0vg + 0.0vh + 0.0vi + 0.0vj + 0.0vk + 0.0vl + 0.0vm + 0.0vn + 0.0w¬π + 0.0w¬≤ + 0.0w¬≥ + 0.0w‚Å¥ + 0.0w‚Åµ + 0.0w‚Å∂ + 0.0w‚Å∑ + 0.0w‚Å∏ + 0.0w‚Åπ + 0.0w‚Å∞ + 0.0wA + 0.0wB + 0.0wC + 0.0wD + 0.0wE + 0.0wF + 0.0wG + 0.0wH + 0.0wI + 0.0wJ + 0.0wK + 0.0wL + 0.0wM + 0.0wN

julia&gt; Leech(E24.v3)
1.414213562373095v‚ÇÅ + 0.0v‚ÇÇ + 1.414213562373095v‚ÇÉ + 0.0v‚ÇÑ + 0.0v‚ÇÖ + 0.0v‚ÇÜ + 0.0v‚Çá + 0.0v‚Çà + 0.0v‚Çâ + 0.0v‚ÇÄ + 0.0va + 0.0vb + 0.0vc + 0.0vd + 0.0ve + 0.0vf + 0.0vg + 0.0vh + 0.0vi + 0.0vj + 0.0vk + 0.0vl + 0.0vm + 0.0vn + 0.0w¬π + 0.0w¬≤ + 0.0w¬≥ + 0.0w‚Å¥ + 0.0w‚Åµ + 0.0w‚Å∂ + 0.0w‚Å∑ + 0.0w‚Å∏ + 0.0w‚Åπ + 0.0w‚Å∞ + 0.0wA + 0.0wB + 0.0wC + 0.0wD + 0.0wE + 0.0wF + 0.0wG + 0.0wH + 0.0wI + 0.0wJ + 0.0wK + 0.0wL + 0.0wM + 0.0wN

...</code></pre><p>Then a <code>TensorAlgebra</code> evaluation of <code>Leech</code> at an <code>Integer</code> linear combination would be</p><pre><code class="language-julia">julia&gt; Leech(E24.v1 + 2*E24.v2)
5.65685424949238v‚ÇÅ + 2.82842712474619v‚ÇÇ + 0.0v‚ÇÉ + 0.0v‚ÇÑ + 0.0v‚ÇÖ + 0.0v‚ÇÜ + 0.0v‚Çá + 0.0v‚Çà + 0.0v‚Çâ + 0.0v‚ÇÄ + 0.0va + 0.0vb + 0.0vc + 0.0vd + 0.0ve + 0.0vf + 0.0vg + 0.0vh + 0.0vi + 0.0vj + 0.0vk + 0.0vl + 0.0vm + 0.0vn + 0.0w¬π + 0.0w¬≤ + 0.0w¬≥ + 0.0w‚Å¥ + 0.0w‚Åµ + 0.0w‚Å∂ + 0.0w‚Å∑ + 0.0w‚Å∏ + 0.0w‚Åπ + 0.0w‚Å∞ + 0.0wA + 0.0wB + 0.0wC + 0.0wD + 0.0wE + 0.0wF + 0.0wG + 0.0wH + 0.0wI + 0.0wJ + 0.0wK + 0.0wL + 0.0wM + 0.0wN

julia&gt; ans‚ãÖans
39.99999999999999v

julia&gt; Leech(E24.v2 + E24.v5)
2.82842712474619v‚ÇÅ + 1.414213562373095v‚ÇÇ + 0.0v‚ÇÉ + 0.0v‚ÇÑ + 0.0v‚ÇÖ + 0.0v‚ÇÜ + 0.0v‚Çá + 0.0v‚Çà + 0.0v‚Çâ + 0.0v‚ÇÄ + 1.414213562373095va + 0.0vb + 0.0vc + 0.0vd + 0.0ve + 0.0vf + 0.0vg + 0.0vh + 0.0vi + 0.0vj + 0.0vk + 0.0vl + 0.0vm + 0.0vn + 0.0w¬π + 0.7071067811865475w¬≤ + 1.414213562373095w¬≥ + 1.414213562373095w‚Å¥ + 0.0w‚Åµ + 0.0w‚Å∂ + 0.0w‚Å∑ + 0.0w‚Å∏ + 0.0w‚Åπ + 0.0w‚Å∞ + 0.0wA + 0.0wB + 0.0wC + 0.0wD + 0.0wE + 0.0wF + 0.0wG + 0.0wH + 0.0wI + 0.0wJ + 0.0wK + 0.0wL + 0.0wM + 0.0wN

julia&gt; ans‚ãÖans
7.499999999999998v</code></pre><p>The <code>Grassmann</code> package is designed to smoothly handle high-dimensional bivector algebras with headroom to spare. Although some of these calculations may have an initial delay, repeated calls are fast due to built-in caching and pre-compilation.</p><p>In future updates, more emphasis will be placed on increased type-stability with more robust sparse output allocation in the computational graph and minimal footprint but maximal type-stability for intermediate results and output.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../algebra-of-space/">¬´ The Algebra of Space (G3)</a><a class="docs-footer-nextpage" href="../../references/">References ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 2 May 2021 19:36">Sunday 2 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
