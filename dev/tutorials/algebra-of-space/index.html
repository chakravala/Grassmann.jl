<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Algebra of Space (G3) ¬∑ Grassmann.jl</title><meta name="title" content="The Algebra of Space (G3) ¬∑ Grassmann.jl"/><meta property="og:title" content="The Algebra of Space (G3) ¬∑ Grassmann.jl"/><meta property="twitter:title" content="The Algebra of Space (G3) ¬∑ Grassmann.jl"/><meta name="description" content="Documentation for Grassmann.jl."/><meta property="og:description" content="Documentation for Grassmann.jl."/><meta property="twitter:description" content="Documentation for Grassmann.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Grassmann.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Grassmann.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../design/">Design</a></li><li><a class="tocitem" href="../../algebra/">Algebra</a></li><li><a class="tocitem" href="../../videos/">Videos</a></li><li><a class="tocitem" href="../../library/">Library</a></li><li><a class="tocitem" href="../../agpl/">AGPL-3.0</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../quick-start/">Quick start (G2)</a></li><li class="is-active"><a class="tocitem" href>The Algebra of Space (G3)</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#Reflections"><span>Reflections</span></a></li><li><a class="tocitem" href="#Rotations"><span>Rotations</span></a></li><li><a class="tocitem" href="#Barycentric-Coordinates"><span>Barycentric Coordinates</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>The Algebra of Space (G3)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Algebra of Space (G3)</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Algebra-of-Space-(G3)"><a class="docs-heading-anchor" href="#The-Algebra-of-Space-(G3)">The Algebra of Space (G3)</a><a id="The-Algebra-of-Space-(G3)-1"></a><a class="docs-heading-anchor-permalink" href="#The-Algebra-of-Space-(G3)" title="Permalink"></a></h1><p>This notebook is an adaptation from the <a href="https://clifford.readthedocs.io/en/latest/TheAlgebraOfSpaceG3.html">clifford</a> python documentation.</p><p>Import <code>Grassmann</code> and instantiate a three dimensional geometric algebra</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Grassmann</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; basis&quot;3&quot;</code><code class="nohighlight hljs ansi" style="display:block;">(‚ü®111‚ü©, v, v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, v‚ÇÅ‚ÇÇ, v‚ÇÅ‚ÇÉ, v‚ÇÇ‚ÇÉ, v‚ÇÅ‚ÇÇ‚ÇÉ)</code></pre><p>Given a three dimensional GA with the orthonormal basis <span>$v_i\cdot v_j = \delta_{ij}$</span>, the basis consists of scalars, three vectors, three bivectors, and a trivector.</p><p class="math-container">\[\{\underbrace{v}_{\text{scalar}},\qquad\underbrace{v_1,v_2,v_3}_{\text{vectors}},\qquad\underbrace{v_{12},v_{23},v_{13}}_{\text{bivectors}},\qquad\underbrace{v_{123}}_{\text{trivector}}\}\]</p><p>The <code>@basis</code> macro declares the algebra and assigns the <code>Submanifold</code> elements to local variables. The <code>Basis</code> can also be assigned to <code>G3</code> as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; G3 = Œõ(3)</code><code class="nohighlight hljs ansi" style="display:block;">DirectSum.Basis{‚ü®111‚ü©,8}(v, v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, v‚ÇÅ‚ÇÇ, v‚ÇÅ‚ÇÉ, v‚ÇÇ‚ÇÉ, v‚ÇÅ‚ÇÇ‚ÇÉ)</code></pre><p>You may wish to explicitly assign the blades to variables like so,</p><pre><code class="language-julia hljs">e1 = G3.v1
e2 = G3.v2
# etc ...</code></pre><p>Or, if you&#39;re lazy you can use the macro with different local names</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @basis ‚Ñù^3 E e</code><code class="nohighlight hljs ansi" style="display:block;">(‚ü®+++‚ü©, v, v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, v‚ÇÅ‚ÇÇ, v‚ÇÅ‚ÇÉ, v‚ÇÇ‚ÇÉ, v‚ÇÅ‚ÇÇ‚ÇÉ)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e3, e123</code><code class="nohighlight hljs ansi" style="display:block;">(v‚ÇÉ, v‚ÇÅ‚ÇÇ‚ÇÉ)</code></pre><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>The basic products are available</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v1 * v2 # geometric product</code><code class="nohighlight hljs ansi" style="display:block;">v‚ÇÅ‚ÇÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v1 | v2 # inner product</code><code class="nohighlight hljs ansi" style="display:block;">ùüé</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v1 ‚àß v2 # exterior product</code><code class="nohighlight hljs ansi" style="display:block;">v‚ÇÅ‚ÇÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v1 ‚àß v2 ‚àß v3 # even more exterior products</code><code class="nohighlight hljs ansi" style="display:block;">v‚ÇÅ‚ÇÇ‚ÇÉ</code></pre><p>Multivectors can be defined in terms of the basis blades. For example, you can construct a rotor as a sum of a scalar and a bivector, like so</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Œ∏ = œÄ/4</code><code class="nohighlight hljs ansi" style="display:block;">0.7853981633974483</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = cos(Œ∏) + sin(Œ∏)*v23</code><code class="nohighlight hljs ansi" style="display:block;">0.7071067811865476 + 0.7071067811865475v‚ÇÇ‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = exp(Œ∏*v23)</code><code class="nohighlight hljs ansi" style="display:block;">0.7071067811865476 + 0.7071067811865475v‚ÇÇ‚ÇÉ</code></pre><p>You can also mix grades without any reason</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = 1 + 2v1 + 3v12 + 4v123</code><code class="nohighlight hljs ansi" style="display:block;">1 + 2v‚ÇÅ + 3v‚ÇÅ‚ÇÇ + 4v‚ÇÅ‚ÇÇ‚ÇÉ</code></pre><p>The reversion operator is accomplished with the tilde <code>~</code> in front of the <code>Multivector</code> on which it acts</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ~A</code><code class="nohighlight hljs ansi" style="display:block;">1 + 2v‚ÇÅ - 3v‚ÇÅ‚ÇÇ - 4v‚ÇÅ‚ÇÇ‚ÇÉ</code></pre><p>Taking a projection into a specific <code>grade</code> of a <code>Multivector</code> is usually written <span>$\langle A\rangle_n$</span> and can be done using the soft brackets, like so</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A(0)</code><code class="nohighlight hljs ansi" style="display:block;">1v</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A(1)</code><code class="nohighlight hljs ansi" style="display:block;">2v‚ÇÅ + 0v‚ÇÇ + 0v‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A(2)</code><code class="nohighlight hljs ansi" style="display:block;">3v‚ÇÅ‚ÇÇ + 0v‚ÇÅ‚ÇÉ + 0v‚ÇÇ‚ÇÉ</code></pre><p>Using the reversion and grade projection operators, we can define the magnitude of <code>A</code> as <span>$|A|^2 = \langle\tilde A A\rangle$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ~A*A</code><code class="nohighlight hljs ansi" style="display:block;">30 + 4v‚ÇÅ + 12v‚ÇÇ + 24v‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; scalar(ans)</code><code class="nohighlight hljs ansi" style="display:block;">30v</code></pre><p>This is done in the <code>abs</code> and <code>abs2</code> operators</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; abs2(A)</code><code class="nohighlight hljs ansi" style="display:block;">30 + 4v‚ÇÅ + 12v‚ÇÇ + 24v‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; scalar(ans)</code><code class="nohighlight hljs ansi" style="display:block;">30v</code></pre><p>The dual of a multivector <code>A</code> can be defined as <span>$\tilde AI$</span>, where <code>I</code> is the pseudoscalar for the geometric algebra. In <code>G3</code>, the dual of a vector is a bivector:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 1v1 + 2v2 + 3v3</code><code class="nohighlight hljs ansi" style="display:block;">1v‚ÇÅ + 2v‚ÇÇ + 3v‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ãÜa</code><code class="nohighlight hljs ansi" style="display:block;">3v‚ÇÅ‚ÇÇ - 2v‚ÇÅ‚ÇÉ + 1v‚ÇÇ‚ÇÉ</code></pre><h2 id="Reflections"><a class="docs-heading-anchor" href="#Reflections">Reflections</a><a id="Reflections-1"></a><a class="docs-heading-anchor-permalink" href="#Reflections" title="Permalink"></a></h2><p>Reflecting a vector <span>$c$</span> about a normalized vector <span>$n$</span> is pretty simple, <span>$c\mapsto -ncn$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = v1+v2+v3 # a vector</code><code class="nohighlight hljs ansi" style="display:block;">1v‚ÇÅ + 1v‚ÇÇ + 1v‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = v1 # the reflector</code><code class="nohighlight hljs ansi" style="display:block;">v‚ÇÅ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; -n*c*n # reflect a in hyperplane normal to n</code><code class="nohighlight hljs ansi" style="display:block;">-1v‚ÇÅ + 1v‚ÇÇ + 1v‚ÇÉ + 0v‚ÇÅ‚ÇÇ‚ÇÉ</code></pre><p>Because we have the <code>inv</code> available, we can equally well reflect in un-normalized vectors using <span>$a\mapsto n^{-1}an$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = v1+v2+v3 # the vector</code><code class="nohighlight hljs ansi" style="display:block;">1v‚ÇÅ + 1v‚ÇÇ + 1v‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = 3v1 # the reflector</code><code class="nohighlight hljs ansi" style="display:block;">3v‚ÇÅ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; inv(n)*a*n</code><code class="nohighlight hljs ansi" style="display:block;">1.0v‚ÇÅ - 1.0v‚ÇÇ - 1.0v‚ÇÉ + 0.0v‚ÇÅ‚ÇÇ‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n\a*n</code><code class="nohighlight hljs ansi" style="display:block;">1.0v‚ÇÅ - 1.0v‚ÇÇ - 1.0v‚ÇÉ + 0.0v‚ÇÅ‚ÇÇ‚ÇÉ</code></pre><p>Reflections can also be made with respect to the hyperplane normal to the vector, in which case the formula is negated.</p><h2 id="Rotations"><a class="docs-heading-anchor" href="#Rotations">Rotations</a><a id="Rotations-1"></a><a class="docs-heading-anchor-permalink" href="#Rotations" title="Permalink"></a></h2><p>A vector can be rotated using the formula <span>$a\mapsto \tilde R aR$</span>, where <code>R</code> is a rotor. A rotor can be defined by multiple reflections, <span>$R = mn$</span> or by a plane and an angle <span>$R = e^{\theta B/2}$</span>. For example,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = exp(œÄ/4*v12)</code><code class="nohighlight hljs ansi" style="display:block;">0.7071067811865476 + 0.7071067811865475v‚ÇÅ‚ÇÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ~R*v1*R</code><code class="nohighlight hljs ansi" style="display:block;">2.22045e-16v‚ÇÅ + 1.0v‚ÇÇ + 0.0v‚ÇÉ + 0.0v‚ÇÅ‚ÇÇ‚ÇÉ</code></pre><p>Maybe we want to define a function which can return rotor of some angle <span>$\theta$</span> in the <span>$v_{12}$</span>-plane, <span>$R_{12} = e^{\theta v_{12}/2}$</span></p><pre><code class="language-julia hljs">R12(Œ∏) = exp(Œ∏/2*v12)</code></pre><p>And use it like this</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = R12(œÄ/2)</code><code class="nohighlight hljs ansi" style="display:block;">0.7071067811865476 + 0.7071067811865475v‚ÇÅ‚ÇÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = v1+v2+v3</code><code class="nohighlight hljs ansi" style="display:block;">1v‚ÇÅ + 1v‚ÇÇ + 1v‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ~R*a*R</code><code class="nohighlight hljs ansi" style="display:block;">-1.0v‚ÇÅ + 1.0v‚ÇÇ + 1.0v‚ÇÉ + 0.0v‚ÇÅ‚ÇÇ‚ÇÉ</code></pre><p>You might as well make the angle argument a bivector, so that you can control the plane of rotation as well as the angle</p><pre><code class="language-julia hljs">R_B(B) = exp(B/2)</code></pre><p>Then you could do</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rxy = R_B(œÄ/4*v12)</code><code class="nohighlight hljs ansi" style="display:block;">0.9238795325112867 + 0.3826834323650898v‚ÇÅ‚ÇÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ryz = R_B(œÄ/5*v23)</code><code class="nohighlight hljs ansi" style="display:block;">0.9510565162951535 + 0.3090169943749474v‚ÇÇ‚ÇÉ</code></pre><p>or</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; R_B(œÄ/6*(v23+v12))</code><code class="nohighlight hljs ansi" style="display:block;">0.93224 + 0.255859v‚ÇÅ‚ÇÇ + 0.0v‚ÇÅ‚ÇÉ + 0.255859v‚ÇÇ‚ÇÉ</code></pre><p>Maybe you want to define a function which returns a <em>function</em> that enacts a specified rotation, <span>$f(B) = a\mapsto e^{B/2}\\ae^{B/2}$</span>. This just saves you having to write out the sandwich product, which is nice if you are cascading a bunch of rotors, like so</p><pre><code class="language-julia hljs">R_factory(B) = (R = exp(B/2); a -&gt; ~R*a*R)
Rxy = R_factory(œÄ/3*v12)
Ryz = R_factory(œÄ/3*v23)
Rxz = R_factory(œÄ/3*v13)</code></pre><p>Then you can do things like</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = R_factory(œÄ/6*(v23+v12)) # this returns a function</code><code class="nohighlight hljs ansi" style="display:block;">#1 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R(a) # which acts on a vector</code><code class="nohighlight hljs ansi" style="display:block;">0.522956v‚ÇÅ + 0.738144v‚ÇÇ + 1.47704v‚ÇÉ + 0.0v‚ÇÅ‚ÇÇ‚ÇÉ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rxy(Ryz(Rxz(a)))</code><code class="nohighlight hljs ansi" style="display:block;">0.408494v‚ÇÅ - 0.658494v‚ÇÇ + 1.54904v‚ÇÉ + 0.0v‚ÇÅ‚ÇÇ‚ÇÉ</code></pre><p>To make cascading a sequence of rotations as concise as possible, we could define a function which takes a list of bivectors <span>$A,B,C,...$</span>, and enacts the sequence of rotations which they represent on some vector <span>$x$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; R_seq(args...) = (R = prod(exp.(args./2)); a -&gt; ~R*a*R)</code><code class="nohighlight hljs ansi" style="display:block;">R_seq (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = R_seq(œÄ/2*v23, œÄ/2*v12, v1)</code><code class="nohighlight hljs ansi" style="display:block;">#3 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R(v1)</code><code class="nohighlight hljs ansi" style="display:block;">2.22045e-16 + 3.33067e-16v‚ÇÅ + 1.0v‚ÇÇ + 5.55112e-17v‚ÇÇ‚ÇÉ</code></pre><h2 id="Barycentric-Coordinates"><a class="docs-heading-anchor" href="#Barycentric-Coordinates">Barycentric Coordinates</a><a id="Barycentric-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Barycentric-Coordinates" title="Permalink"></a></h2><p>We can find the barycentric coordinates of a point in a triangle using area ratios.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function barycoords(p, a, b, c)
         ab = b-a
         ca = a-c
         bc = c-b
         A = -ab‚àßca
         (bc‚àß(p-b)/A, ca‚àß(p-c)/A, ab‚àß(p-a)/A)
       end</code><code class="nohighlight hljs ansi" style="display:block;">barycoords (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; barycoords(0.25v1+0.25v2, 0v1, 1v1, 1v2)</code><code class="nohighlight hljs ansi" style="display:block;">(0.5 + 0.0v‚ÇÅ‚ÇÇ + 0.0v‚ÇÅ‚ÇÉ - 0.0v‚ÇÇ‚ÇÉ, 0.25 + 0.0v‚ÇÅ‚ÇÇ + 0.0v‚ÇÅ‚ÇÉ - 0.0v‚ÇÇ‚ÇÉ, 0.25 + 0.0v‚ÇÅ‚ÇÇ + 0.0v‚ÇÅ‚ÇÉ - 0.0v‚ÇÇ‚ÇÉ)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quick-start/">¬´ Quick start (G2)</a><a class="docs-footer-nextpage" href="../../references/">References ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 10 June 2025 16:13">Tuesday 10 June 2025</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
